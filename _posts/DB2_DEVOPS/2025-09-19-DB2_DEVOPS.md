---
layout: post
title: DB2 en el ciclo de vida DevOps
date: 2025-09-19 07:00
modified: 2025-09-19 08:00
description: ğŸš€ DB2 en el ciclo de vida DevOps - AutomatizaciÃ³n y Buenas PrÃ¡cticas
tag:
  - DB2
  - DevOps
  - CI/CD
  - AutomatizaciÃ³n
  - Control de versiones
  - Infraestructura como CÃ³digo
  - IBM
  - AzureDevOps
  - GitHubActions
image: /DB2_DEVOPS/DB2_DEVOPS.png
---

# ğŸš€ DB2 en el ciclo de vida DevOps: AutomatizaciÃ³n y Buenas PrÃ¡cticas

En el mundo moderno del desarrollo de software, hablar de **DevOps** no es solo hablar de despliegues rÃ¡pidos, sino de lograr un equilibrio entre **velocidad, calidad y seguridad**. Las aplicaciones han evolucionado y adoptado prÃ¡cticas Ã¡giles, pero muchas veces la **base de datos** queda relegada en la sombra, tratada como un elemento rÃ­gido y difÃ­cil de automatizar.

Si trabajas con **DB2**, ya sea en **IBM i** o en entornos distribuidos (LUW), seguramente conoces bien esta realidad:
- Scripts aplicados manualmente en cada ambiente.
- Diferencias entre QA y ProducciÃ³n que generan errores difÃ­ciles de rastrear.
- Rollbacks que requieren largas noches de trabajo.

La integraciÃ³n de **DB2 en DevOps** busca eliminar estos puntos de dolor. No se trata de reinventar la rueda, sino de aplicar las mismas prÃ¡cticas que ya usamos en cÃ³digo de aplicaciÃ³n: **versionado, automatizaciÃ³n, pruebas y monitoreo**.

<figure>
<img src="./DEVOPS_IBMi_DB2.png" alt="RepresentaciÃ³n de la integraciÃ³n de DB2 en DevOps" />
<figcaption>Fig 1. RepresentaciÃ³n de la integraciÃ³n de DB2 en DevOps</figcaption>
</figure>

## ğŸ”¹ 1. IntegraciÃ³n de scripts SQL en pipelines (Azure DevOps / GitHub Actions)

El primer paso para modernizar la gestiÃ³n de DB2 es **automatizar la ejecuciÃ³n de scripts SQL**.

### Problema comÃºn
Un desarrollador crea un script para agregar una columna. Lo aplica en su ambiente local, lo manda por correo o lo comparte en Teams, y alguien mÃ¡s lo copia en ProducciÃ³n. Esto genera inconsistencias, errores humanos y falta de trazabilidad.

### SoluciÃ³n DevOps
Incluir el script en el **repositorio Git** y que sea ejecutado automÃ¡ticamente por un **pipeline CI/CD**.

ğŸ“Œ **Ejemplo con GitHub Actions:**
```yaml
name: Deploy DB2 Scripts

on:
  push:
    branches: [ "main" ]

jobs:
  run-sql:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Instalar cliente DB2
        run: |
          sudo apt-get update
          sudo apt-get install -y db2cli

      - name: Ejecutar script SQL en DB2
        run: db2 -tvf scripts/migracion.sql
        env:
          DB2USER: ${{ secrets.DB2_USER }}
          DB2PASS: ${{ secrets.DB2_PASS }}
          DB2HOST: ${{ secrets.DB2_HOST }}
```

âœ… Beneficios:
- Consistencia entre ambientes.
- EjecuciÃ³n automÃ¡tica en cada *push*.
- Seguridad gracias a secretos cifrados.


## ğŸ”¹ 2. Control de versiones para objetos DB2

En DevOps, todo lo que no estÃ¡ versionado **no existe**.

### Â¿QuÃ© versionar?
- **DDL** de tablas.
- **Ãndices** y constraints.
- **Stored Procedures** y funciones.
- **Triggers**.

### Estructura recomendada del repositorio:
```
/db2
   /tables
      clientes.sql
      cuentas.sql
   /indexes
      idx_clientes_nombre.sql
   /procedures
      proc_valida_cliente.sql
   /migrations
      001_add_email_clientes.sql
      002_update_index_cuentas.sql
```

ğŸ“Œ **Ejemplo de tabla versionada (`clientes.sql`):**
```sql
CREATE TABLE clientes (
    cliente_id INT NOT NULL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    direccion VARCHAR(200),
    telefono VARCHAR(20)
);
```

ğŸ“Œ **Ejemplo de Ã­ndice (`idx_clientes_nombre.sql`):**
```sql
CREATE INDEX idx_clientes_nombre
ON clientes (nombre);
```

âœ… Ventajas:
- Historial de cambios con `git log`.
- RevisiÃ³n por pares vÃ­a *pull requests*.
- Posibilidad de revertir con `git revert`.


## ğŸ”¹ 3. Liquibase: quÃ© es, para quÃ© sirve y por quÃ© importa

Hasta aquÃ­ hemos visto control de versiones y ejecuciÃ³n de scripts. Pero, Â¿quÃ© pasa si algo falla en medio de una migraciÃ³n? AquÃ­ entra **Liquibase**.

### ğŸ”‘ Â¿QuÃ© es Liquibase?
Es una herramienta de **gestiÃ³n de cambios de base de datos** que permite:
- Versionar migraciones.
- Automatizar despliegues.
- Definir **rollbacks**.
- Auditar cambios en entornos mÃºltiples.

### ğŸ“Œ Â¿Por quÃ© usarlo con DB2?
- Garantiza que todos los ambientes (DEV, QA, PROD) tienen el mismo estado.
- Provee **consistencia** y elimina el â€œdriftâ€ entre esquemas.
- Se integra perfectamente en pipelines de CI/CD.
- Hace que la base de datos sea tratada igual que el cÃ³digo: controlada, trazable y confiable.

En resumen: **Liquibase convierte cambios manuales en procesos automatizados y reversibles**.


## ğŸ”¹ 4. Migraciones seguras con rollback automatizado

Un cambio en base de datos puede fallar. Lo importante no es solo aplicar el cambio, sino poder **revertirlo de forma automÃ¡tica**.

ğŸ“Œ **Ejemplo de changelog con rollback (`changelog.xml`):**  
```xml
<databaseChangeLog>
  <changeSet id="001" author="jdetri">
    <addColumn tableName="clientes">
      <column name="email" type="VARCHAR(100)"/>
    </addColumn>
    <rollback>
      <dropColumn tableName="clientes" columnName="email"/>
    </rollback>
  </changeSet>
</databaseChangeLog>
```


ğŸ“Œ **Pipeline en Azure DevOps con Liquibase:**  

<figure>
<img src="./Pipelines_DB2_IBMi.png" alt="RepresentaciÃ³n de los pipelines de DB2 en entornos IBMi" />
<figcaption>Fig 2. RepresentaciÃ³n de los pipelines de DB2 en entornos IBMi</figcaption>
</figure>

```yaml
- stage: Deploy
  jobs:
    - job: LiquibaseMigration
      steps:
        - task: Liquibase@1
          inputs:
            driver: 'com.ibm.db2.jcc.DB2Driver'
            changeLogFile: 'changelog.xml'
            url: 'jdbc:db2://$(DB2HOST):50000/MYDB'
            username: $(DB2USER)
            password: $(DB2PASS)
            command: 'update'
```

âœ… Beneficio: Si el cambio falla â†’ Liquibase ejecuta el rollback.


## ğŸ”¹ 5. ValidaciÃ³n de sintaxis antes de QA

Aplicar un script con errores en ProducciÃ³n puede ser desastroso. Por eso, un **stage de validaciÃ³n** es clave.

ğŸ“Œ **Ejemplo simple en Azure DevOps:**
```yaml
- stage: Validate
  jobs:
    - job: SQLValidation
      steps:
        - script: db2 -tvf scripts/migracion.sql
```

ğŸ‘‰ Con esto:
- El pipeline detecta errores sintÃ¡cticos.
- QA recibe solo scripts vÃ¡lidos.
- Se reduce el tiempo perdido en correcciones.


## ğŸ”¹ 6. Testing automatizado de queries crÃ­ticos

En DB2 hay queries que **no pueden fallar** (ejemplo: balances bancarios, cierres financieros). Estos deben tener **pruebas automÃ¡ticas**.

ğŸ“Œ **Ejemplo de prueba SQL:**
```sql
-- Datos de prueba
INSERT INTO cuentas (cliente_id, saldo_total) VALUES (123, 1000);

-- Query crÃ­tico
SELECT saldo_total FROM cuentas WHERE cliente_id = 123;

-- ValidaciÃ³n esperada
ASSERT resultado = 1000;
```

ğŸ“Œ **Ejemplo en Python con pyodbc:**
```python
import pyodbc

conn = pyodbc.connect("DRIVER={IBM DB2 ODBC DRIVER};DATABASE=MYDB;HOSTNAME=host;PORT=50000;UID=user;PWD=pass;")
cursor = conn.cursor()

cursor.execute("SELECT saldo_total FROM cuentas WHERE cliente_id = 123")
row = cursor.fetchone()

assert row[0] == 1000, "El saldo no coincide con el esperado"
```

âœ… Integrar este test en un pipeline asegura que si el query falla, **el despliegue se detiene**.


## ğŸ”¹ 7. Buenas prÃ¡cticas de DB2 en entornos DevOps

- Nunca ejecutar scripts manualmente en ProducciÃ³n.
- Mantener **nombres claros** en migraciones (`001_add_email.sql`, `002_fix_index.sql`).
- Alinear cambios de aplicaciÃ³n y DB (branch â†’ pull request â†’ pipeline).
- Siempre probar en un entorno **sandbox/QA** antes de PROD.
- Usar **monitorizaciÃ³n** para detectar queries lentos post-despliegue.


## ğŸš€ ConclusiÃ³n

La base de datos ya no puede ser vista como un bloque estÃ¡tico fuera del ciclo de desarrollo. Con las prÃ¡cticas de DevOps y herramientas como **Liquibase**, DB2 se convierte en un actor mÃ¡s dentro del flujo de entrega continua.

Con estas prÃ¡cticas:
1. **Scripts SQL** integrados en pipelines.
2. **Control de versiones** con Git.
3. **Migraciones seguras** con rollback.
4. **ValidaciÃ³n automÃ¡tica** de sintaxis.
5. **Pruebas automatizadas** de queries crÃ­ticos.
6. **Buenas prÃ¡cticas** alineadas con el ciclo de vida Ã¡gil.
